{"version":3,"sources":["components/Pose.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Pose","props","webCam","camCanvas","stream","poseNet","HEIGHT","WIDTH","ctx","poses","modelLoaded","lastAngleData","findElementPoints","element1Name","element2Name","element3Name","keypoints","Array","isArray","element1","find","keypoint","part","element2","element3","response","findAngle","position","p0","p1","p2","a","Math","pow","x","y","b","c","acos","sqrt","React","state","detected","this","ml5","current","flipHorizontal","maxPoseDetections","scoreThreshold","console","log","on","result","setState","undefined","length","i","angleData","pose","j","score","fillStyle","font","fillText","round","angle","beginPath","arc","PI","fill","map","skeleton","skeletonElement","partA","partB","moveTo","lineTo","stroke","drawImage","drawKeypoints","drawSkeleton","requestAnimationFrame","drawCameraIntoCanvas","bind","getContext","navigator","mediaDevices","getUserMedia","Error","facingMode","width","height","frameRate","then","res","srcObject","play","initializeModel","getTracks","forEach","track","stop","className","ref","playsInline","style","display","App","path","exact","component","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.65e69638.chunk.js","sourcesContent":["\nimport * as React from 'react';\n\ndeclare var ml5: any;\n\nexport interface IPoseProps {\n}\n\nexport interface IPoseState {\n    detected?: boolean\n}\n\nexport default class Pose extends React.Component<IPoseProps, IPoseState> {\n    private webCam: React.RefObject<HTMLVideoElement>;\n    private camCanvas: React.RefObject<HTMLCanvasElement>;\n    private stream: MediaStream;\n    private poseNet: any;\n    private HEIGHT: number;\n    private WIDTH: number;\n    private ctx: CanvasRenderingContext2D;\n    private poses: any;\n    private modelLoaded: boolean;\n    private lastAngleData: any = null;\n\n    constructor(props: IPoseProps) {\n        super(props);\n        this.webCam = React.createRef();\n        this.camCanvas = React.createRef();\n        this.HEIGHT = 700;\n        this.WIDTH = 1000;\n        this.modelLoaded = false;\n        this.state = {\n            detected: false\n        };\n    }\n\n    initializeModel() {\n        this.poseNet = ml5.poseNet(\n            this.webCam.current, \n            { \n                flipHorizontal: false,\n                maxPoseDetections: 1,\n                scoreThreshold: .9,\n            }, \n            () => {\n            console.log(\"Model Initilaized\");\n            this.modelLoaded = true;\n            this.poseNet.on('pose', (result: any) => {\n                this.poses = result;\n\n                this.setState({\n                    detected: result !== undefined && result.length > 0 ? true : false\n                })\n            });\n        });\n    }\n\n    drawKeypoints() {\n        for (let i = 0; i < this.poses.length; i++) {\n            let angleData = null;\n            if(this.poses[i].pose.keypoints) {\n                angleData = this.findElementPoints(\n                    'leftShoulder',\n                    'leftWrist',\n                    'leftElbow',\n                    this.poses[i].pose.keypoints\n                )\n\n                if(angleData) {\n                    this.lastAngleData = angleData;\n                }\n                angleData = angleData || this.lastAngleData;\n            }\n\n            for (let j = 0; j < this.poses[i].pose.keypoints.length; j++) {\n                let keypoint = this.poses[i].pose.keypoints[j];\n                if (keypoint.score > 0.3) {\n                    if(keypoint.part === 'leftElbow') {\n                        this.ctx.fillStyle = \"#ff5736\";\n                        this.ctx.font = \"30px Arial\";\n                        if(angleData) {\n                            this.ctx.fillText(`${keypoint.part} - ${Math.round(angleData.angle * 100)}*`, keypoint.position.x, keypoint.position.y);\n                        } else {\n                            this.ctx.fillText(keypoint.part, keypoint.position.x, keypoint.position.y);\n                        }\n                    } else {\n                        this.ctx.fillStyle = \"#349eeb\";\n                        this.ctx.font = \"18px Arial\";\n                        this.ctx.fillText(keypoint.part, keypoint.position.x, keypoint.position.y);\n                    }\n\n                    this.ctx.beginPath();\n                    this.ctx.arc(keypoint.position.x, keypoint.position.y, 5, 0, 2 * Math.PI);\n                    this.ctx.fill();\n                }\n            }\n        }\n    }\n\n    drawSkeleton() {\n        this.poses.map(pose => {\n            pose.skeleton.map(skeletonElement => {\n                const partA = skeletonElement[0];\n                const partB = skeletonElement[1];\n\n                this.ctx.beginPath();\n                this.ctx.moveTo(partA.position.x, partA.position.y);\n                this.ctx.lineTo(partB.position.x, partB.position.y);\n                this.ctx.stroke();\n            });\n        });\n    }\n\n    findElementPoints = (element1Name, element2Name, element3Name, keypoints) => {\n        if(!keypoints || !Array.isArray(keypoints)) return null;\n\n        // console.log(keypoints);\n        const element1 = keypoints.find(keypoint => keypoint.part === element1Name);\n        const element2 = keypoints.find(keypoint => keypoint.part === element2Name);\n        const element3 = keypoints.find(keypoint => keypoint.part === element3Name);\n        \n        let response = null;\n        if(element1 && element2 && element3) {\n            // console.log(element1,  element2, element3);\n            response = {\n                [element1Name]: element1,\n                [element2Name]: element2,\n                [element3Name]: element3,\n                angle: this.findAngle(element1.position, element2.position, element3.position)\n            };\n\n            // console.log(response);\n        }\n\n        return response\n    }\n\n    findAngle = (p0,p1,p2)  => {\n        let a = Math.pow(p1.x-p0.x,2) + Math.pow(p1.y-p0.y,2);\n        let b = Math.pow(p1.x-p2.x,2) + Math.pow(p1.y-p2.y,2);\n        let c = Math.pow(p2.x-p0.x,2) + Math.pow(p2.y-p0.y,2);\n        \n        return Math.acos( (a+b-c) / Math.sqrt(4*a*b) );\n    }\n\n    drawCameraIntoCanvas() {\n        if (this.modelLoaded) {\n            this.ctx.drawImage(this.webCam.current, 0, 0, this.WIDTH, this.HEIGHT)\n        }\n        if (this.poses !== undefined) {\n            this.drawKeypoints();\n            this.drawSkeleton();\n        }\n        requestAnimationFrame(this.drawCameraIntoCanvas.bind(this));\n    }\n\n    componentDidMount() {\n        this.ctx = this.camCanvas.current.getContext('2d');\n        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n            throw new Error('Browser API navigator.mediaDevices.getUserMedia not available');\n        }\n\n        navigator.mediaDevices\n            .getUserMedia({\n                'audio': false,\n                'video': {\n                    facingMode: 'user',\n                    width: this.WIDTH,\n                    height: this.HEIGHT,\n                    frameRate: 15, // Reduce this if there's a stuttering in feed\n                },\n            }).then(res => {\n                if (res != null) {\n                    this.stream = res;\n                    this.webCam.current!.srcObject = this.stream;\n                    this.webCam.current?.play();\n\n                    this.drawCameraIntoCanvas();\n                    this.initializeModel();\n                }\n            });\n    }\n\n    componentWillUnmount() {\n        if (this.stream) {\n            this.stream.getTracks().forEach(track => track.stop());\n        }\n    }\n\n    public render() {\n        const camStyle: React.CSSProperties = {\n            display: 'none'\n        }\n\n        return (\n            <div className=\"container\">\n                {/* <h2>Posenet on ml5</h2> */}\n                <canvas ref={this.camCanvas} width={this.WIDTH} height={this.HEIGHT} />\n                <video playsInline ref={this.webCam} width={this.WIDTH} height={this.HEIGHT} style={camStyle} />\n                {this.state.detected ? \"Found You!!!\" : \"Show yourself\"}\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport './App.css';\nimport Pose from './components/Pose';\nimport Face from './components/Face';\nimport { BrowserRouter as Router, Switch, Route, NavLink } from 'react-router-dom'\n\ninterface Props {\n\n}\n\ninterface State {\n\n}\n\nexport default class App extends React.Component<Props, State>{\n  render() {\n    return (\n      <Router>\n        <div className=\"app\">\n          {/* <header className=\"app-header\">\n            <NavLink to=\"/\"><h5>Pose-Net</h5></NavLink>\n            <NavLink to=\"/face\"><h5>Face-Api</h5></NavLink>\n          </header> */}\n          <div className=\"app-body\">\n            <Switch>\n              <Route path=\"/\" exact component={Pose} />\n              {/* <Route path=\"/face\" exact component={Face} /> */}\n            </Switch>\n          </div>\n        </div>\n      </Router>\n    )\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}